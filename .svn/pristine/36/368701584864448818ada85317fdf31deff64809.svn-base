/*
 * Made by:
 * Uroš Podkrižnik
 * uros.podkriznik(at)gmail.com
 * Tel.: 041829380
 */

package enklikanketa.com.a1kapanel.System;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

import enklikanketa.com.a1kapanel.Libraries.GeneralLib;

public class Database extends SQLiteOpenHelper {

    private String TAG = "Database";

    /**
     * Ko se naredi upgrade baze, je treba popravit v funkciji createDatabase(), dodati case v
     * onUpgrade() in popravit konstanto DATABASE_VERSION
     */
    private static final int DATABASE_VERSION = 4;

    private SQLiteDatabase db;

    public Database(Context cont) {
        super(cont, "1kapanel_baza", null, DATABASE_VERSION);
        //if DB is not created yet, this will return null, but in onCrate it will initialize
        db = getWritableDatabase();
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        this.db = db;
        createDatabase();
        //insert device data
        ContentValues[] valuesArr = getDeviceInfoValues();
        for(ContentValues values : valuesArr)
            insertData("device_info", values);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        while (oldVersion < newVersion)
        {
            switch (oldVersion)
            {
                case 0:
                case 1:
                    Log.d(TAG, "Database upgraded to 2.");
                    //tabela, kjer so shranjene info o anketah
                    db.execSQL("DROP TABLE IF EXISTS surveys;");
                    db.execSQL("CREATE TABLE IF NOT EXISTS surveys "
                            + "(id INTEGER PRIMARY KEY, link VARCHAR);");
                    //tabela, kjer so shranjene info o alarmih
                    db.execSQL("DROP TABLE IF EXISTS alarms;");
                    db.execSQL("CREATE TABLE IF NOT EXISTS alarms "
                            + "(alarm_id INTEGER PRIMARY KEY, srv_id INTEGER, alarm_notif_title VARCHAR, " +
                            "alarm_notif_message VARCHAR, alarm_notif_repeat INTEGER, alarm_notif_sound TINYINT, " +
                            "FOREIGN KEY(srv_id) REFERENCES surveys(id) ON DELETE CASCADE);");
                    break;
                case 2:
                    Log.d(TAG, "Database upgraded to 3.");
                    db.execSQL("DROP TABLE IF EXISTS things_to_send;");
                    db.execSQL("CREATE TABLE IF NOT EXISTS things_to_send "
                            + "(name VARCHAR, value VARCHAR, event VARCHAR, tsSec INTEGER);");
                    break;
                case 3:
                    db.execSQL("DROP TABLE IF EXISTS alarms;");
                    db.execSQL("CREATE TABLE IF NOT EXISTS alarms "
                            + "(alarm_id INTEGER PRIMARY KEY, srv_id INTEGER, alarm_notif_title VARCHAR, " +
                            "alarm_notif_message VARCHAR, alarm_notif_repeat VARCHAR, alarm_notif_sound TINYINT, " +
                            "FOREIGN KEY(srv_id) REFERENCES surveys(id) ON DELETE CASCADE);");
                    break;
            }
            oldVersion++;
        }
    }

    @Override
    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        while (oldVersion > newVersion)
        {
            switch (oldVersion)
            {
                case 0:
                case 1:
                    Log.d(TAG, "Database upgraded to 0.");
                    break;
                case 2:
                    Log.d(TAG, "Database onDowngrade to 1.");
                    //tabela, kjer so shranjene info o anketah
                    db.execSQL("DROP TABLE IF EXISTS surveys;");
                    //tabela, kjer so shranjene info o alarmih
                    db.execSQL("DROP TABLE IF EXISTS alarms;");
                    break;
                case 3:
                    Log.d(TAG, "Database onDowngrade to 2.");
                    db.execSQL("DROP TABLE IF EXISTS things_to_send;");
                    break;
                case 4:
                    db.execSQL("DROP TABLE IF EXISTS alarms;");
                    db.execSQL("CREATE TABLE IF NOT EXISTS alarms "
                            + "(alarm_id INTEGER PRIMARY KEY, srv_id INTEGER, alarm_notif_title VARCHAR, " +
                            "alarm_notif_message VARCHAR, alarm_notif_repeat INTEGER, alarm_notif_sound TINYINT, " +
                            "FOREIGN KEY(srv_id) REFERENCES surveys(id) ON DELETE CASCADE);");
                    break;
            }
            oldVersion--;
        }
    }

    @Override
    public void onConfigure(SQLiteDatabase db){
        super.onConfigure(db);
        db.setForeignKeyConstraintsEnabled(true);
    }

    /**
     * get DB of app
     *
     * @param dbh SQLiteOpenHelper
     * @return SQLiteDatabase 1kapanel_baza
     */
    /*private SQLiteDatabase openDb(SQLiteOpenHelper dbh) {
        return  dbh.getWritableDatabase();
        //return ctx.openOrCreateDatabase("1kapanel_baza", 0, null);
    }*/

    /**
     * Update DB - remove all tables and create new ones <br>
     * <b>This function will remove all stored data</b>
     */
    private void createDatabase() {
        Log.e(TAG, "Database.createDatabase() "+db);
        try {
            //tabela, kjer je shranjen uporabnik
            db.execSQL("DROP TABLE IF EXISTS uporabnik;");
            db.execSQL("CREATE TABLE IF NOT EXISTS uporabnik "
                    + "(id INTEGER PRIMARY KEY, identifier VARCHAR, id_server INTEGER);");
            //tabela, kjer so shranjene info o napravi
            db.execSQL("DROP TABLE IF EXISTS device_info;");
            db.execSQL("CREATE TABLE IF NOT EXISTS device_info "
                    + "(name VARCHAR, value VARCHAR);");
            //tabela, kjer so shranjene info o anketah
            db.execSQL("DROP TABLE IF EXISTS surveys;");
            db.execSQL("CREATE TABLE IF NOT EXISTS surveys "
                    + "(id INTEGER PRIMARY KEY, link VARCHAR);");
            //tabela, kjer so shranjene info o alarmih
            db.execSQL("DROP TABLE IF EXISTS alarms;");
            db.execSQL("CREATE TABLE IF NOT EXISTS alarms "
                    + "(alarm_id INTEGER PRIMARY KEY, srv_id INTEGER, alarm_notif_title VARCHAR, " +
                    "alarm_notif_message VARCHAR, alarm_notif_repeat VARCHAR, alarm_notif_sound TINYINT, " +
                    "FOREIGN KEY(srv_id) REFERENCES surveys(id) ON DELETE CASCADE);");
            //table of things to send when connection available
            db.execSQL("DROP TABLE IF EXISTS things_to_send;");
            db.execSQL("CREATE TABLE IF NOT EXISTS things_to_send "
                    + "(name VARCHAR, value VARCHAR, event VARCHAR, tsSec INTEGER);");
        } catch (Exception e) {
            //Log.e(TAG, "Database.upgradeDatabase() - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
        }
    }//upgradeDatabase

    /**
     * Delete data from table
     * <br>db.execSQL("DELETE FROM " + table + ";");
     *
     * @param table name of table
     */
    public void deleteAllRows(String table) {
        //SQLiteDatabase db = getWritableDatabase();
        try {
            db.execSQL("DELETE FROM " + table + ";");

            //db.close();
        } catch (Exception e) {
            //Log.e(TAG, "Database.deleteAllRows() - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
        }
    }//deleteAllRows

    /**
     * Delete data from table
     * <br>db.execSQL("DELETE FROM " + table + ";");
     *
     * @param table name of table
     * @param where where statement
     */
    public void deleteRows(String table, String where) {
        //SQLiteDatabase db = getWritableDatabase();
        try {
            db.execSQL("DELETE FROM " + table + " WHERE " + where + ";");

            //db.close();
        } catch (Exception e) {
            //Log.e(TAG, "Database.deleteAllRows() - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
        }
    }//deleteAllRows

    /**
     * Get data from app's DB for one array (one survey, one question,...)
     * unique ID is usualy in where statement
     *
     * @param table   name of table
     * @param columns wanted columns to get
     * @param where   where statement, null if not needed (eg for user email)
     * @return String array of data
     */
    public String[] getRowData(String table, String[] columns, String where) {
        //SQLiteDatabase db = getReadableDatabase();
        String[] temp_array = null;

        try {
            Cursor c = db.query(table, columns, where, null, null, null, null);
            if (c.getCount() != 0) {
                temp_array = new String[c.getColumnCount()];
                c.moveToFirst();
                for (int i = 0; i < c.getColumnCount(); i++) {
                    temp_array[i] = c.getString(i);
                }
            } else {
                Log.d(TAG, "Database.getRowData() - No data");
            }
            c.close();
            ////db.close();
            return temp_array;
        } catch (Exception e) {
            //Log.e(TAG, "Database.getRowData() - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
            return null;
        }
    }//getRowData

    /**
     * Get data from app's DB
     * unique ID is usualy in where statement
     *
     * @param table   name of table
     * @param columns wanted columns to get
     * @param where   where statement, null if not needed (eg for user email)
     * @return String array of data
     */
    public String[][] getData(String table, String[] columns, String where) {
        //SQLiteDatabase db = getReadableDatabase();
        String[][] temp_array = null;

        try {
            Cursor c = db.query(table, columns, where, null, null, null, null);
            int ccount = c.getCount();
            if (ccount != 0) {
                temp_array = new String[ccount][c.getColumnCount()];
                c.moveToFirst();
                for(int i = 0; i < ccount; i++) {
                    for (int j = 0; j < c.getColumnCount(); j++) {
                        temp_array[i][j] = c.getString(j);
                    }
                    c.moveToNext();
                }
            } else {
                Log.d(TAG, "Database.getData() - No data");
            }
            c.close();
            //db.close();
            return temp_array;
        } catch (Exception e) {
            //Log.e(TAG, "Database.getData() - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
            return null;
        }
    }//getData

    /**
     * Get data from app's DB in JSONArray
     * unique ID is usualy in where statement
     *
     * @param table   name of table
     * @param columns wanted columns to get
     * @param where   where statement, null if not needed (eg for user email)
     * @return String array of data
     */
    public JSONArray getJSONData(String table, String[] columns, String where) {
        //SQLiteDatabase db = getReadableDatabase();
        JSONArray temp_array = new JSONArray();

        try {
            Cursor c = db.query(table, columns, where, null, null, null, null);
            int ccount = c.getCount();
            if (ccount != 0) {
                c.moveToFirst();
                for(int i = 0; i < ccount; i++) {
                    JSONObject jsonObj = new JSONObject();
                    for (int j = 0; j < c.getColumnCount(); j++) {
                        jsonObj.put(c.getColumnName(j), c.getString(j));
                    }
                    temp_array.put(jsonObj);
                    c.moveToNext();
                }
            } else {
                Log.d(TAG, "Database.getData() - No data");
            }
            c.close();
            //db.close();
            if(temp_array.length() == 0)
                return null;
            else
                return temp_array;
        } catch (Exception e) {
            //Log.e(TAG, "Database.getData() - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
            return null;
        }
    }//getData

    /**
     * Insert new row in DB
     *
     * @param table   name of table
     * @param podatki data to insert - eg {{ "name_of_column", "value" },...}
     * @return id of new row - int id = getLastID(db);
     */
    public int insertData(String table, String[][] podatki) {
        //SQLiteDatabase db = getWritableDatabase();
        try {
            String values = "", columns = "";

            //kreiraj string vrstic in vrednosti
            for (int i = 0; i < podatki.length; i++) {
                if (podatki[i][1] != null) {
                    if (i == 0) {
                        columns = podatki[i][0];
                        values = "'" + podatki[i][1].replaceAll("'", "''") + "'";
                    } else {
                        columns += ", " + podatki[i][0];
                        values += ", '" + podatki[i][1].replaceAll("'", "''") + "'";
                    }
                }
            }

            db.execSQL("INSERT INTO " + table + " (" + columns + ") "
                    + "VALUES (" + values + ");");

            //pridobi nazadnje pridobljen id
            int id = getLastID(table);
            //db.close();
            return id;
        } catch (Exception e) {
            //Log.e(TAG, "Database.insertData() - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
            return -1;
        }
    }//insertData

    /**
     * Get data from app's DB for multiple arrays
     *
     * @param table   name of table
     * @param columns wanted columns to get
     * @param where   where statement, null if not needed
     * @return String[ROW_INDEX][VALUES] of data
     */
    public String[][] getPairData(String table, String[] columns, String where) {
        //SQLiteDatabase db = getReadableDatabase();
        String[][] temp_array = null;

        try {
            Cursor c = db.query(table, columns, where, null, null, null, null);
            if (c.getCount() != 0) {
                temp_array = new String[c.getCount()][c.getColumnCount()];
                c.moveToFirst();
                do{
                    for (int col = 0; col < c.getColumnCount(); col++) {
                        temp_array[c.getPosition()][col] = c.getString(col);
                    }
                }
                while (c.moveToNext());
            } else {
                Log.d(TAG, "Database.getPairData() - No data");
            }
            c.close();
            //db.close();
            return temp_array;
        } catch (Exception e) {
            //Log.e(TAG, "Database.getPairData() - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
            return null;
        }
    }//getPairData

    /**
     * Update row in DB
     *
     * @param table   name of table
     * @param podatki ContentValues values
     * @return id of new row - int id = getLastID(db);
     */
    public int updateData(String table, ContentValues podatki, String where) {
        //SQLiteDatabase db = getWritableDatabase();
        try {
            int numRows = 0;

            if(podatki.size() > 0)
                numRows = db.update(table, podatki, where, null);
            else
                Log.w(TAG, "Database.updateData() - no data to insert");

            //db.close();
            return numRows;
        } catch (Exception e) {
            //Log.e(TAG, "Database.updateData() - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
            return 0;
        }
    }//updateData

    /**
     * Insert new row in DB
     *
     * @param table   name of table
     * @param podatki ContentValues values
     * @return id of new row or -1 if nothing inserted;
     */
    public long insertData(String table, ContentValues podatki) {
        //SQLiteDatabase db = getWritableDatabase();
        try {
            long id = -1;

            if(podatki.size() > 0)
                id = db.insert(table, null, podatki);
            else
                Log.w(TAG, "Database.insertData() - no data to insert");

            //db.close();
            return id;
        } catch (Exception e) {
            //Log.e(TAG, "Database.insertData() - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
            return -1;
        }
    }//insertData

    /**
     * Convert HashMap<String, String> to ContentValues
     * @param podatki data to convert
     * @return converted ContentValues
     */
    public ContentValues convertToValues(HashMap<String, String> podatki){
        ContentValues values = new ContentValues();
        for (Map.Entry<String, String> entry : podatki.entrySet()){
            if (entry.getKey() != null || entry.getValue() != null)
                values.put(entry.getKey(), entry.getValue());
            else
                Log.w(TAG, "Database.convertToValues() - null value in pair: " + entry.getKey() + " = " + entry.getValue());
        }
        return values;
    }

    /**
     * Convert String[][] to ContentValues
     * @param podatki data to convert - eg {{ "name_of_column", "value" },...}
     * @return converted ContentValues
     */
    public ContentValues convertToValues(String[][] podatki){
        ContentValues values = new ContentValues();
        for (String[] pair : podatki){
            if (pair[0] != null || pair[1] != null)
                values.put(pair[0], pair[1]);
            else
                Log.w(TAG, "Database.convertToValues() - null value in pair: " + pair[0] + " = " + pair[1]);
        }
        return values;
    }

    /**
     * Count rows in table
     *
     * @param table name of table to count rows
     * @param where where statement, null if not needed
     * @return number (int) of rows counted
     */
    public int stejData(String table, String where) {
        //SQLiteDatabase db = getReadableDatabase();
        try {
            Cursor c = db.query(table, null, where, null, null, null, null);

            //if there is no rows in table
            if (c.getCount() == 0) {
                c.close();
                //db.close();
                return 0;
            }

            c.close();
            //db.close();
            return c.getCount();
        } catch (Exception e) {
            //Log.e(TAG, "Database.stejData - Error: " + e.getMessage());
            GeneralLib.reportCrash(e, null);
            return 0;
        }
    }//stejData

    /**
     * Get ID of last added row in DB
     *
     * @param table name of table
     * @return ID of last added row (int)
     */
    private int getLastID(String table) {
        //SQLiteDatabase db = getReadableDatabase();
        Cursor cur;
        if (table.equals(""))
            cur = db.rawQuery("SELECT last_insert_rowid()", null);
        else
            cur = db.rawQuery("SELECT ROWID from " + table + " order by ROWID DESC limit 1", null);

        //db.close();
        if (cur.getCount() != 0) {
            cur.moveToFirst();
            int ID = cur.getInt(0);
            cur.close();
            return ID;
        } else
            return 0;
    }//getLastID

    /**
     * Create ContentValues of device info, ready to insert them in DB
     * @return ContentValues of device info
     */
    private ContentValues[] getDeviceInfoValues() {
        String [][] pairsArr = {{"os_version", System.getProperty("os.version")+""},
                {"incremental", android.os.Build.VERSION.INCREMENTAL+""},
                {"sdk_int", android.os.Build.VERSION.SDK_INT+""},
                {"release", android.os.Build.VERSION.RELEASE+""},
                {"device", android.os.Build.DEVICE+""},
                {"model", android.os.Build.MODEL+""},
                {"product", android.os.Build.PRODUCT+""},
                {"brand", android.os.Build.BRAND+""},
                {"manufacturer", android.os.Build.MANUFACTURER+""},
                {"serial", android.os.Build.SERIAL+""},
                {"display", android.os.Build.DISPLAY+""},
                {"unknown", android.os.Build.UNKNOWN+""},
                {"hardware", android.os.Build.HARDWARE+""},
                {"id", android.os.Build.ID+""},
                {"user", android.os.Build.USER+""},
                {"host", android.os.Build.HOST+""},
                {"rooted", findBinary("su")+""},};


        ContentValues[] valuesArr = new ContentValues[pairsArr.length];
        for(int i = 0; i < pairsArr.length; i++){
            ContentValues values = new ContentValues();
            values.put("name", pairsArr[i][0]);
            values.put("value", pairsArr[i][1]);
            valuesArr[i] = values;
        }

        return valuesArr;
    }//end getDeviceSuperInfo

    //Find out if device is rooted

    /**
     * Find out fi device is rooted
     * @param binaryName - string to find (usualy "su")
     * @return boolean - true for rooted, false for otherwise
     */
    private boolean findBinary(String binaryName) {
        boolean found = false;
        String[] places = { "/sbin/", "/system/bin/", "/system/xbin/",
                "/data/local/xbin/", "/data/local/bin/",
                "/system/sd/xbin/", "/system/bin/failsafe/", "/data/local/" };
        for (String where : places) {
            if (new File(where + binaryName).exists()) {
                found = true;

                break;
            }
        }
        return found;
    }
}
